    def load_geojson(self):
        logging.debug("Loading England and Wales WPC data")
        england_wpc = gpd.read_file("data/England_WPC.json")
        wales_wpc = gpd.read_file("data/Wales_WPC.json")
        NI_wpc = gpd.read_file("data/NI_WPC.json")
        Scotland_wpc = gpd.read_file("data/Scotland_WPC.json")

        combined_wpc = pd.concat([england_wpc, wales_wpc, NI_wpc, Scotland_wpc], ignore_index=True)
        logging.debug(f"Combined dataset has {len(combined_wpc)} rows")

        logging.debug("Filtering for Bristol region constituencies")
        focused_region = combined_wpc[combined_wpc['PCON13NM'].isin(self.constituencies)].copy()
        logging.info(f"Found {len(focused_region)} constituencies in the region")

        logging.debug("Cleaning geometry and creating boundary")
        focused_region.geometry = focused_region.geometry.buffer(0)
        focused_region = focused_region[focused_region.geometry.is_valid]
        allboundaries_shape = shapely.ops.unary_union(focused_region.geometry)

        if isinstance(allboundaries_shape, MultiPolygon):
            logging.debug("Converting MultiPolygon to unified boundary")
            boundary_shape = shapely.ops.unary_union(allboundaries_shape)

        logging.debug("Boundary shape created successfully")
        return boundary_shape, allboundaries_shape

def get_populations(self):
        logging.debug("Getting populations from GeoJSON")

        geojsontuple = self.load_geojson()
        popjson = geojsontuple[1]
        self.boundary_shape = popjson
        popnetwork = gpd.GeoDataFrame(geometry=[popjson])
        logging.debug("Created population boundary shape")
        return popnetwork


    def show_pops(self, show_garages=False, show_roads=False, show_traffic=False, voronoi_type: VoronoiType = None, traffic_hour: int = None, coord: Tuple[float, float] = None):
        """
        Plot network visualisation with optional layers

        Args:
            show_garages (bool): Whether to show garage locations
            show_roads (bool): Whether to show the road network
            show_traffic (bool): Whether to show the traffic data
            voronoi_type (VoronoiType): Type of Voronoi diagram to display (if any)
        """
        logging.debug("Plotting network visualisation")

        ax = self.population.plot(edgecolor='black', facecolor='none')

        # if voronoi_type:
        #     logging.debug(f"Adding {voronoi_type.value} Voronoi regions to plot")
        #     filtered_garages = self.garages.gdf[self.garages.gdf.geometry.within(self.network.geometry.iloc[0])]
        #
        #     if voronoi_type == VoronoiType.NONE:
        #         pass
        #     elif voronoi_type == VoronoiType.EUCLIDEAN and self.euclidean_voronoi:
        #         for idx, region in enumerate(self.euclidean_voronoi.values()):
        #             if isinstance(region, (shapely.Polygon, shapely.MultiPolygon)):
        #                 color = plt.cm.tab20(idx / len(filtered_garages))
        #                 gpd.GeoDataFrame(geometry=[region]).plot(
        #                     ax=ax,
        #                     color=color,
        #                     alpha=0.7,
        #                     edgecolor=color
        #                 )
        #     elif voronoi_type == VoronoiType.NETWORK and self.network_voronoi:
        #         for idx, region in enumerate(self.network_voronoi.values()):
        #             if isinstance(region, (shapely.Polygon, shapely.MultiPolygon)):
        #                 color = plt.cm.tab20(idx / len(filtered_garages))
        #                 gpd.GeoDataFrame(geometry=[region]).plot(
        #                     ax=ax,
        #                     color=color,
        #                     alpha=1.0,
        #                     edgecolor=color
        #                 )
        #     elif voronoi_type == VoronoiType.TRAFFIC:
        #         if traffic_hour is None:
        #             logging.warning("No hour specified for traffic Voronoi visualisation")
        #             return
        #
        #         logging.debug(f"Adding traffic-weighted Voronoi regions for hour {traffic_hour}")
        #         if traffic_hour in self.traffic_voronoi:
        #             for idx, region in enumerate(self.traffic_voronoi[traffic_hour].values()):
        #                 if isinstance(region, (shapely.Polygon, shapely.MultiPolygon)):
        #                     color = plt.cm.tab20(idx / len(filtered_garages))
        #                     gpd.GeoDataFrame(geometry=[region]).plot(
        #                         ax=ax,
        #                         color=color,
        #                         alpha=0.7,
        #                         edgecolor=color
        #                     )
        #         else:
        #             logging.warning(f"No traffic-weighted Voronoi regions available for hour {traffic_hour}")
        #
        # if show_roads:
        #     logging.debug("Adding road network to plot")
        #     roads_gdf = gpd.GeoDataFrame(geometry=[
        #         data['geometry'] for _, _, data in self.get_road_network().edges(data=True)
        #         if 'geometry' in data
        #     ])
        #
        #     roads_gdf.plot(ax=ax, color='black', linewidth=0.5, alpha=0.3)
        #
        #     if show_traffic:
        #         logging.debug("Adding traffic data visualisation")
        #         traffic_df = TrafficData().df
        #         # TODO: Add traffic data visualiation
        #
        # if show_garages:
        #     logging.debug("Adding garage locations to plot")
        #     filtered_garages = self.garages.gdf[self.garages.gdf.geometry.within(self.network.geometry.iloc[0])]
        #     filtered_garages.plot(ax=ax, color='red', markersize=40, zorder=3)
        #
        # if coord:
        #     logging.debug(f"Adding coordinate {coord} to plot")
        #     # Plot as blue circle with proper size and zorder
        #     plt.scatter(
        #         coord[1],  # longitude (x)
        #         coord[0],  # latitude (y)
        #         color='blue',
        #         s=40,       # marker size
        #         zorder=4,
        #         label='Selected Location'
        #     )

        plt.gcf().set_size_inches(12, 8)
        ax.set_axis_off()
        plt.tight_layout()
        plt.show()
        logging.debug("Network visualisation complete")
